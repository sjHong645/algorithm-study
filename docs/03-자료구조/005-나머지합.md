
## 기존 내 코드의 문제 

시간복잡도를 줄인다고 합 배열까지 만들었는데 2중 for문을 써버려서 시간복잡도를 낮추지 못함 

그리고 제발 `생각하고 설계해서` 문제를 풀자. 아무 생각없이 들이받지 말고 

## 교재에서 소개한 내용

문제를 요약하면 다음과 같다.
```
(i번째 값 ~ j번째 값의 합) % M = 0 이 되도록 하는 (i, j) 의 경우의 수를 구하는 문제 
```

그런데 `i번째 값 ~ j번째 값의 합`은 `합 배열`을 이용하면 `S[j] - S[i+1]`로 표현할 수 있다. 

즉, `(S[j] - S[i+1]) % M = 0`이 되도록 하는 (i, j)의 경우의 수를 구하는 문제 

⇒ 이 부분에서 나는 경우의 수를 구하기 위해 `2중 for문`을 적용했다. 하지만, 이는 시간이 오래걸린다. 

- idea 

(S[j] - S[i+1]) % M = 0 <==> (S[j] % M - S[i+1] % M) % M = 0이다. 

따라서, 합 배열 S 자체를 가지고 놀지 말고 합 배열 S의 원소에 `%M` 연산을 실행하자. 

ex) arr = {1, 2, 3, 1, 2}, M = 3

그러면 합 배열 S = {1, 3, 6, 7, 9} ==> `%M`을 하면 {1, 0, 0, 1, 0} 

- 값이 0이라는 건 1 ~ i번째 값의 합이 M으로 나눠떨어진다는 뜻. 따라서 경우의 수 3가지 
- (S[j] % M - S[i+1] % M) % M = 0 식을 보면 
    - `S[j] % M`과 `S[i+1] % M`가 서로 같으면 나머지 값이 0이 된다는 걸 유도할 수 있다.
    - 따라서, 0 3개 중 2개를 고르는 경우의 수 = 3C2 = 3
    - 1 2개 중 2개를 고르는 경우의 수 = 2C2 = 1 

총 경우의 수는 7가지가 된다. 